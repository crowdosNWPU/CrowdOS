/*
 * Copyright 2019-2025 CrowdOS_Group, Inc. <https://github.com/crowdosNWPU/CrowdOS>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * imitations under the License.
 */
package cn.crowdos.kernel.constraint;

import cn.crowdos.kernel.DecomposeException;
import cn.crowdos.kernel.Decomposer;
import cn.crowdos.kernel.wrapper.DateCondition;

import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;

/**
 *
 * A constraint that represents a date interval between a start date and an end date.
 * The constraint can be decomposed into multiple sub-constraints, each representing a smaller date interval.
 * The constraint can be satisfied by a date condition that falls within the date interval.
 */

public class DateInterval implements Constraint{
    private final LocalDate startDate;
    private final LocalDate endDate;

    /**
     * Constructs a DateInterval with the given start and end dates.
     * Throws an InvalidConstraintException if the end date is before the start date.
     *
     * @param startDate the start date of the interval
     * @param endDate the end date of the interval
     * @throws InvalidConstraintException if the end date is before the start date
     */
    public DateInterval(LocalDate startDate, LocalDate endDate) throws InvalidConstraintException{
        this.startDate = startDate;
        this.endDate = endDate;
        if(endDate.isBefore(startDate)){
            throw new InvalidConstraintException(String.format("endDate %s is before startDate %s",this.endDate,this.startDate));
        }
    }


    /**
     * Constructs a DateInterval with the given start and end dates as strings.
     *
     * @param start the start date of the interval as a string
     * @param end the end date of the interval as a string
     * @throws InvalidConstraintException if the end date is before the start date
     */

    public DateInterval(String start, String end) throws InvalidConstraintException {
        this(LocalDate.parse(start), LocalDate.parse(end));
    }

    /**
     * Decomposes the constraint into a list of sub-constraints.
     * The scale parameter determines the number of sub-constraints to be generated.
     *
     * @return A list of sub-constraints generated by decomposing the constraint
     */
    @Override
    public Decomposer<Constraint> decomposer() {
        return new Decomposer<Constraint>() {
            @Override
            public List<Constraint> trivialDecompose() {
                try{
                    return Collections.singletonList(new DateInterval(startDate,endDate));
                }catch (InvalidConstraintException e){
                    throw new RuntimeException(e);
                }
            }

            @Override
            public List<Constraint> scaleDecompose(int scale) throws DecomposeException {
                if (scale<0) throw new DecomposeException("invalid decompose scale");
                if (scale==1) return trivialDecompose();
                Duration duration = Duration.between(startDate.atStartOfDay(),endDate.atStartOfDay());
                long totalHours = duration.toDays()*24;
                long hoursPerInterval = totalHours/scale;
                List<Constraint> subConstraints = new ArrayList<>(scale);
                for(int i=0;i<scale;i++){
                    LocalDate intervalStartDate = startDate.plusDays((i*hoursPerInterval)/24);
                    LocalDate intervalEndDate = intervalStartDate.plusDays(hoursPerInterval/24);
                    try{
                        subConstraints.add(new DateInterval(intervalStartDate,intervalEndDate));
                    }catch(InvalidConstraintException e){
                        throw new DecomposeException(e);
                    }
                }
                return subConstraints;
            }
        };
    }

    /**
     * Checks if the given condition satisfies the constraint.
     *
     * @param condition The condition to check
     * @return true if the condition falls within the interval, false otherwise
     */
    @Override
    public boolean satisfy(Condition condition) {
        if(!(condition instanceof Date)) return false;
        Date date = (Date) condition;
        LocalDate localDate = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault()).toLocalDate();
        return localDate.equals(startDate) || (localDate.isAfter(startDate)) &&localDate.isBefore(endDate);
    }

    /**
     *
     * Returns the condition class associated with this data interval, which is {@link DateCondition}.
     *  @return the condition class associated with this data interval
     */
    @Override
    public Class<? extends Condition> getConditionClass() {
        return DateCondition.class;
    }

    /**
     *
     * Returns a string representation of this data interval, which contains the start date and end date.
     * @return a string representation of this data interval
     */
    @Override
    public String toString() {
        return "DataInterval{" +
                "startDate=" + startDate +
                ", endDate=" + endDate +
                '}';
    }
    /**
     *
     * Returns a description of this data interval, which is the same as its string representation.
     * @return a description of this data interval
     */
    @Override
    public String description() {
        return this.toString();
    }
}
